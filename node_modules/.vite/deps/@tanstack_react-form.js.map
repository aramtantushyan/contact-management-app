{
  "version": 3,
  "sources": ["../../@tanstack/form-core/src/utils.ts", "../../@tanstack/form-core/src/standardSchemaValidator.ts", "../../@tanstack/form-core/src/FormApi.ts", "../../@tanstack/form-core/src/FieldApi.ts", "../../@tanstack/form-core/src/mergeForm.ts", "../../@tanstack/form-core/src/formOptions.ts", "../../@tanstack/react-form/src/useIsomorphicLayoutEffect.ts", "../../@tanstack/react-form/src/useField.tsx", "../../@tanstack/react-form/src/useTransform.ts"],
  "sourcesContent": ["import type { ValidationCause } from './types'\nimport type { FormValidators } from './FormApi'\nimport type { FieldValidators } from './FieldApi'\n\nexport type UpdaterFn<TInput, TOutput = TInput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput = TInput> =\n  | TOutput\n  | UpdaterFn<TInput, TOutput>\n\n/**\n * @private\n */\nexport function functionalUpdate<TInput, TOutput = TInput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as UpdaterFn<TInput, TOutput>)(input)\n    : updater\n}\n\n/**\n * Get a value from an object using a path, including dot notation.\n * @private\n */\nexport function getBy(obj: any, path: any) {\n  const pathObj = makePathArray(path)\n  return pathObj.reduce((current: any, pathPart: any) => {\n    if (current === null) return null\n    if (typeof current !== 'undefined') {\n      return current[pathPart]\n    }\n    return undefined\n  }, obj)\n}\n\n/**\n * Set a value on an object using a path, including dot notation.\n * @private\n */\nexport function setBy(obj: any, _path: any, updater: Updater<any>) {\n  const path = makePathArray(_path)\n\n  function doSet(parent?: any): any {\n    if (!path.length) {\n      return functionalUpdate(updater, parent)\n    }\n\n    const key = path.shift()\n\n    if (\n      typeof key === 'string' ||\n      (typeof key === 'number' && !Array.isArray(parent))\n    ) {\n      if (typeof parent === 'object') {\n        if (parent === null) {\n          parent = {}\n        }\n        return {\n          ...parent,\n          [key]: doSet(parent[key]),\n        }\n      }\n      return {\n        [key]: doSet(),\n      }\n    }\n\n    if (Array.isArray(parent) && typeof key === 'number') {\n      const prefix = parent.slice(0, key)\n      return [\n        ...(prefix.length ? prefix : new Array(key)),\n        doSet(parent[key]),\n        ...parent.slice(key + 1),\n      ]\n    }\n    return [...new Array(key), doSet()]\n  }\n\n  return doSet(obj)\n}\n\n/**\n * Delete a field on an object using a path, including dot notation.\n * @private\n */\nexport function deleteBy(obj: any, _path: any) {\n  const path = makePathArray(_path)\n\n  function doDelete(parent: any): any {\n    if (!parent) return\n    if (path.length === 1) {\n      const finalPath = path[0]!\n      if (Array.isArray(parent) && typeof finalPath === 'number') {\n        return parent.filter((_, i) => i !== finalPath)\n      }\n      const { [finalPath]: remove, ...rest } = parent\n      return rest\n    }\n\n    const key = path.shift()\n\n    if (typeof key === 'string') {\n      if (typeof parent === 'object') {\n        return {\n          ...parent,\n          [key]: doDelete(parent[key]),\n        }\n      }\n    }\n\n    if (typeof key === 'number') {\n      if (Array.isArray(parent)) {\n        if (key >= parent.length) {\n          return parent\n        }\n        const prefix = parent.slice(0, key)\n        return [\n          ...(prefix.length ? prefix : new Array(key)),\n          doDelete(parent[key]),\n          ...parent.slice(key + 1),\n        ]\n      }\n    }\n\n    throw new Error('It seems we have created an infinite loop in deleteBy. ')\n  }\n\n  return doDelete(obj)\n}\n\nconst reFindNumbers0 = /^(\\d*)$/gm\nconst reFindNumbers1 = /\\.(\\d*)\\./gm\nconst reFindNumbers2 = /^(\\d*)\\./gm\nconst reFindNumbers3 = /\\.(\\d*$)/gm\nconst reFindMultiplePeriods = /\\.{2,}/gm\n\nconst intPrefix = '__int__'\nconst intReplace = `${intPrefix}$1`\n\n/**\n * @private\n */\nexport function makePathArray(str: string | Array<string | number>) {\n  if (Array.isArray(str)) {\n    return [...str]\n  }\n\n  if (typeof str !== 'string') {\n    throw new Error('Path must be a string.')\n  }\n\n  return str\n    .replaceAll('[', '.')\n    .replaceAll(']', '')\n    .replace(reFindNumbers0, intReplace)\n    .replace(reFindNumbers1, `.${intReplace}.`)\n    .replace(reFindNumbers2, `${intReplace}.`)\n    .replace(reFindNumbers3, `.${intReplace}`)\n    .replace(reFindMultiplePeriods, '.')\n    .split('.')\n    .map((d) => {\n      if (d.indexOf(intPrefix) === 0) {\n        return parseInt(d.substring(intPrefix.length), 10)\n      }\n      return d\n    })\n}\n\n/**\n * @private\n */\nexport function isNonEmptyArray(obj: any) {\n  return !(Array.isArray(obj) && obj.length === 0)\n}\n\ninterface AsyncValidatorArrayPartialOptions<T> {\n  validators?: T\n  asyncDebounceMs?: number\n}\n\n/**\n * @private\n */\nexport interface AsyncValidator<T> {\n  cause: ValidationCause\n  validate: T\n  debounceMs: number\n}\n\n/**\n * @private\n */\nexport function getAsyncValidatorArray<T>(\n  cause: ValidationCause,\n  options: AsyncValidatorArrayPartialOptions<T>,\n): T extends FieldValidators<any, any>\n  ? Array<\n      AsyncValidator<T['onChangeAsync'] | T['onBlurAsync'] | T['onSubmitAsync']>\n    >\n  : T extends FormValidators<any, any>\n    ? Array<\n        AsyncValidator<\n          T['onChangeAsync'] | T['onBlurAsync'] | T['onSubmitAsync']\n        >\n      >\n    : never {\n  const { asyncDebounceMs } = options\n  const {\n    onChangeAsync,\n    onBlurAsync,\n    onSubmitAsync,\n    onBlurAsyncDebounceMs,\n    onChangeAsyncDebounceMs,\n  } = (options.validators || {}) as\n    | FieldValidators<any, any>\n    | FormValidators<any, any>\n\n  const defaultDebounceMs = asyncDebounceMs ?? 0\n\n  const changeValidator = {\n    cause: 'change',\n    validate: onChangeAsync,\n    debounceMs: onChangeAsyncDebounceMs ?? defaultDebounceMs,\n  } as const\n\n  const blurValidator = {\n    cause: 'blur',\n    validate: onBlurAsync,\n    debounceMs: onBlurAsyncDebounceMs ?? defaultDebounceMs,\n  } as const\n\n  const submitValidator = {\n    cause: 'submit',\n    validate: onSubmitAsync,\n    debounceMs: 0,\n  } as const\n\n  const noopValidator = (\n    validator:\n      | typeof changeValidator\n      | typeof blurValidator\n      | typeof submitValidator,\n  ) => ({ ...validator, debounceMs: 0 }) as const\n\n  switch (cause) {\n    case 'submit':\n      return [\n        noopValidator(changeValidator),\n        noopValidator(blurValidator),\n        submitValidator,\n      ] as never\n    case 'blur':\n      return [blurValidator] as never\n    case 'change':\n      return [changeValidator] as never\n    case 'server':\n    default:\n      return [] as never\n  }\n}\n\ninterface SyncValidatorArrayPartialOptions<T> {\n  validators?: T\n}\n\n/**\n * @private\n */\nexport interface SyncValidator<T> {\n  cause: ValidationCause\n  validate: T\n}\n\n/**\n * @private\n */\nexport function getSyncValidatorArray<T>(\n  cause: ValidationCause,\n  options: SyncValidatorArrayPartialOptions<T>,\n): T extends FieldValidators<any, any>\n  ? Array<\n      SyncValidator<T['onChange'] | T['onBlur'] | T['onSubmit'] | T['onMount']>\n    >\n  : T extends FormValidators<any, any>\n    ? Array<\n        SyncValidator<\n          T['onChange'] | T['onBlur'] | T['onSubmit'] | T['onMount']\n        >\n      >\n    : never {\n  const { onChange, onBlur, onSubmit, onMount } = (options.validators || {}) as\n    | FieldValidators<any, any>\n    | FormValidators<any, any>\n\n  const changeValidator = { cause: 'change', validate: onChange } as const\n  const blurValidator = { cause: 'blur', validate: onBlur } as const\n  const submitValidator = { cause: 'submit', validate: onSubmit } as const\n  const mountValidator = { cause: 'mount', validate: onMount } as const\n\n  // Allows us to clear onServer errors\n  const serverValidator = {\n    cause: 'server',\n    validate: () => undefined,\n  } as const\n\n  switch (cause) {\n    case 'mount':\n      return [mountValidator] as never\n    case 'submit':\n      return [\n        changeValidator,\n        blurValidator,\n        submitValidator,\n        serverValidator,\n      ] as never\n    case 'server':\n      return [serverValidator] as never\n    case 'blur':\n      return [blurValidator, serverValidator] as never\n    case 'change':\n    default:\n      return [changeValidator, serverValidator] as never\n  }\n}\n", "import type {\n  ValidationError,\n  Validator,\n  ValidatorAdapterParams,\n} from './types'\n\ntype Params = ValidatorAdapterParams<StandardSchemaV1Issue>\ntype TransformFn = NonNullable<Params['transformErrors']>\n\nfunction prefixSchemaToErrors(\n  issues: readonly StandardSchemaV1Issue[],\n  transformErrors: TransformFn,\n) {\n  const schema = new Map<string, StandardSchemaV1Issue[]>()\n\n  for (const issue of issues) {\n    const path = [...(issue.path ?? [])]\n      .map((segment) => {\n        const normalizedSegment =\n          typeof segment === 'object' ? segment.key : segment\n        return typeof normalizedSegment === 'number'\n          ? `[${normalizedSegment}]`\n          : normalizedSegment\n      })\n      .join('.')\n      .replace(/\\.\\[/g, '[')\n\n    schema.set(path, (schema.get(path) ?? []).concat(issue))\n  }\n\n  const transformedSchema = {} as Record<string, ValidationError>\n\n  schema.forEach((value, key) => {\n    transformedSchema[key] = transformErrors(value)\n  })\n\n  return transformedSchema\n}\n\nfunction defaultFormTransformer(transformErrors: TransformFn) {\n  return (issues: readonly StandardSchemaV1Issue[]) => ({\n    form: transformErrors(issues as StandardSchemaV1Issue[]),\n    fields: prefixSchemaToErrors(issues, transformErrors),\n  })\n}\n\nexport const standardSchemaValidator =\n  (params: Params = {}): Validator<unknown, StandardSchemaV1<any>> =>\n  () => {\n    const transformFieldErrors =\n      params.transformErrors ??\n      ((issues: StandardSchemaV1Issue[]) =>\n        issues.map((issue) => issue.message).join(', '))\n\n    const getTransformStrategy = (validationSource: 'form' | 'field') =>\n      validationSource === 'form'\n        ? defaultFormTransformer(transformFieldErrors)\n        : transformFieldErrors\n\n    return {\n      validate({ value, validationSource }, fn) {\n        const result = fn['~standard'].validate(value)\n\n        if (result instanceof Promise) {\n          throw new Error('async function passed to sync validator')\n        }\n\n        if (!result.issues) return\n\n        const transformer = getTransformStrategy(validationSource)\n\n        return transformer(result.issues as StandardSchemaV1Issue[])\n      },\n      async validateAsync({ value, validationSource }, fn) {\n        const result = await fn['~standard'].validate(value)\n\n        if (!result.issues) return\n\n        const transformer = getTransformStrategy(validationSource)\n\n        return transformer(result.issues as StandardSchemaV1Issue[])\n      },\n    }\n  }\n\nexport const isStandardSchemaValidator = (\n  validator: unknown,\n): validator is StandardSchemaV1 =>\n  !!validator && '~standard' in (validator as object)\n\n/**\n * The Standard Schema interface.\n */\nexport type StandardSchemaV1<Input = unknown, Output = Input> = {\n  /**\n   * The Standard Schema properties.\n   */\n  readonly '~standard': StandardSchemaV1Props<Input, Output>\n}\n\n/**\n * The Standard Schema properties interface.\n */\ninterface StandardSchemaV1Props<Input = unknown, Output = Input> {\n  /**\n   * The version number of the standard.\n   */\n  readonly version: 1\n  /**\n   * The vendor name of the schema library.\n   */\n  readonly vendor: string\n  /**\n   * Validates unknown input values.\n   */\n  readonly validate: (\n    value: unknown,\n  ) => StandardSchemaV1Result<Output> | Promise<StandardSchemaV1Result<Output>>\n  /**\n   * Inferred types associated with the schema.\n   */\n  readonly types?: StandardSchemaV1Types<Input, Output> | undefined\n}\n/**\n * The result interface of the validate function.\n */\ntype StandardSchemaV1Result<Output> =\n  | StandardSchemaV1SuccessResult<Output>\n  | StandardSchemaV1FailureResult\n/**\n * The result interface if validation succeeds.\n */\ninterface StandardSchemaV1SuccessResult<Output> {\n  /**\n   * The typed output value.\n   */\n  readonly value: Output\n  /**\n   * The non-existent issues.\n   */\n  readonly issues?: undefined\n}\n/**\n * The result interface if validation fails.\n */\ninterface StandardSchemaV1FailureResult {\n  /**\n   * The issues of failed validation.\n   */\n  readonly issues: ReadonlyArray<StandardSchemaV1Issue>\n}\n/**\n * The issue interface of the failure output.\n */\ninterface StandardSchemaV1Issue {\n  /**\n   * The error message of the issue.\n   */\n  readonly message: string\n  /**\n   * The path of the issue, if any.\n   */\n  readonly path?:\n    | ReadonlyArray<PropertyKey | StandardSchemaV1PathSegment>\n    | undefined\n}\n/**\n * The path segment interface of the issue.\n */\ninterface StandardSchemaV1PathSegment {\n  /**\n   * The key representing a path segment.\n   */\n  readonly key: PropertyKey\n}\n/**\n * The Standard Schema types interface.\n */\ninterface StandardSchemaV1Types<Input = unknown, Output = Input> {\n  /**\n   * The input type of the schema.\n   */\n  readonly input: Input\n  /**\n   * The output type of the schema.\n   */\n  readonly output: Output\n}\n", "import { Derived, Store, batch } from '@tanstack/store'\nimport {\n  deleteBy,\n  functionalUpdate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  isNonEmptyArray,\n  setBy,\n} from './utils'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidator,\n} from './standardSchemaValidator'\nimport type { StandardSchemaV1 } from './standardSchemaValidator'\nimport type { FieldApi, FieldMeta, FieldMetaBase } from './FieldApi'\nimport type {\n  FormValidationError,\n  FormValidationErrorMap,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapKeys,\n  ValidationSource,\n  Validator,\n} from './types'\nimport type { DeepKeys, DeepValue } from './util-types'\nimport type { Updater } from './utils'\n\nexport type FieldsErrorMapFromValidator<TFormData> = Partial<\n  Record<DeepKeys<TFormData>, ValidationErrorMap>\n>\n\nexport type FormValidateFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = (props: {\n  value: TFormData\n  formApi: FormApi<TFormData, TFormValidator>\n}) => FormValidationError<TFormData>\n\n/**\n * @private\n */\nexport type FormValidateOrFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> =\n  TFormValidator extends Validator<TFormData, infer TFN>\n    ? TFN | FormValidateFn<TFormData, TFormValidator>\n    :\n        | FormValidateFn<TFormData, TFormValidator>\n        | StandardSchemaV1<TFormData, unknown>\n\n/**\n * @private\n */\nexport type FormValidateAsyncFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = (props: {\n  value: TFormData\n  formApi: FormApi<TFormData, TFormValidator>\n  signal: AbortSignal\n}) => FormValidationError<TFormData> | Promise<FormValidationError<TFormData>>\n\nexport type FormValidator<TFormData, TType, TFn = unknown> = {\n  validate(options: { value: TType }, fn: TFn): ValidationError\n  validateAsync(\n    options: { value: TType },\n    fn: TFn,\n  ): Promise<FormValidationError<TFormData>>\n}\n\ntype ValidationPromiseResult<TFormData> =\n  | {\n      fieldErrors: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      errorMapKey: ValidationErrorMapKeys\n    }\n  | undefined\n\n/**\n * @private\n */\nexport type FormAsyncValidateOrFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> =\n  TFormValidator extends Validator<TFormData, infer FFN>\n    ? FFN | FormValidateAsyncFn<TFormData, TFormValidator>\n    :\n        | FormValidateAsyncFn<TFormData, TFormValidator>\n        | StandardSchemaV1<TFormData, unknown>\n\nexport interface FormValidators<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  /**\n   * Optional function that fires as soon as the component mounts.\n   */\n  onMount?: FormValidateOrFn<TFormData, TFormValidator>\n  /**\n   * Optional function that checks the validity of your data whenever a value changes\n   */\n  onChange?: FormValidateOrFn<TFormData, TFormValidator>\n  /**\n   * Optional onChange asynchronous counterpart to onChange. Useful for more complex validation logic that might involve server requests.\n   */\n  onChangeAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * Optional function that validates the form data when a field loses focus, returns a `FormValidationError`\n   */\n  onBlur?: FormValidateOrFn<TFormData, TFormValidator>\n  /**\n   * Optional onBlur asynchronous validation method for when a field loses focus returns a ` FormValidationError` or a promise of `Promise<FormValidationError>`\n   */\n  onBlurAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onBlurAsyncDebounceMs?: number\n  onSubmit?: FormValidateOrFn<TFormData, TFormValidator>\n  onSubmitAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>\n}\n\n/**\n * @private\n */\nexport interface FormTransform<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  fn: (\n    formBase: FormApi<TFormData, TFormValidator>,\n  ) => FormApi<TFormData, TFormValidator>\n  deps: unknown[]\n}\n\n/**\n * An object representing the options for a form.\n */\nexport interface FormOptions<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  /**\n   * Set initial values for your form.\n   */\n  defaultValues?: TFormData\n  /**\n   * The default state for the form.\n   */\n  defaultState?: Partial<FormState<TFormData>>\n  /**\n   * If true, always run async validation, even when sync validation has produced an error. Defaults to undefined.\n   */\n  asyncAlways?: boolean\n  /**\n   * Optional time in milliseconds if you want to introduce a delay before firing off an async action.\n   */\n  asyncDebounceMs?: number\n  /**\n   * A validator adapter to support usage of extra validation types (IE: Zod, Yup, or Valibot usage)\n   */\n  validatorAdapter?: TFormValidator\n  /**\n   * A list of validators to pass to the form\n   */\n  validators?: FormValidators<TFormData, TFormValidator>\n  /**\n   * A function to be called when the form is submitted, what should happen once the user submits a valid form returns `any` or a promise `Promise<any>`\n   */\n  onSubmit?: (props: {\n    value: TFormData\n    formApi: FormApi<TFormData, TFormValidator>\n  }) => any | Promise<any>\n  /**\n   * Specify an action for scenarios where the user tries to submit an invalid form.\n   */\n  onSubmitInvalid?: (props: {\n    value: TFormData\n    formApi: FormApi<TFormData, TFormValidator>\n  }) => void\n  transform?: FormTransform<TFormData, TFormValidator>\n}\n\n/**\n * An object representing the validation metadata for a field. Not intended for public usage.\n */\nexport type ValidationMeta = {\n  /**\n   * An abort controller stored in memory to cancel previous async validation attempts.\n   */\n  lastAbortController: AbortController\n}\n\n/**\n * An object representing the field information for a specific field within the form.\n */\nexport type FieldInfo<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = {\n  /**\n   * An instance of the FieldAPI.\n   */\n  instance: FieldApi<\n    TFormData,\n    any,\n    Validator<unknown, unknown> | undefined,\n    TFormValidator\n  > | null\n  /**\n   * A record of field validation internal handling.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n}\n\n/**\n * An object representing the current state of the form.\n */\nexport type BaseFormState<TFormData> = {\n  /**\n   * The current values of the form fields.\n   */\n  values: TFormData\n  /**\n   * The error map for the form itself.\n   */\n  errorMap: FormValidationErrorMap\n  /**\n   * An internal mechanism used for keeping track of validation logic in a form.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n  /**\n   * A record of field metadata for each field in the form, not including the derived properties, like `errors` and such\n   */\n  fieldMetaBase: Record<DeepKeys<TFormData>, FieldMetaBase>\n  /**\n   * A boolean indicating if the form is currently in the process of being submitted after `handleSubmit` is called.\n   *\n   * Goes back to `false` when submission completes for one of the following reasons:\n   * - the validation step returned errors.\n   * - the `onSubmit` function has completed.\n   *\n   * Note: if you're running async operations in your `onSubmit` function make sure to await them to ensure `isSubmitting` is set to `false` only when the async operation completes.\n   *\n   * This is useful for displaying loading indicators or disabling form inputs during submission.\n   *\n   */\n  isSubmitting: boolean\n  /**\n   * A boolean indicating if the form has been submitted.\n   */\n  isSubmitted: boolean\n  /**\n   * A boolean indicating if the form or any of its fields are currently validating.\n   */\n  isValidating: boolean\n  /**\n   * A counter for tracking the number of submission attempts.\n   */\n  submissionAttempts: number\n}\n\nexport type DerivedFormState<TFormData> = {\n  /**\n   * A boolean indicating if the form is currently validating.\n   */\n  isFormValidating: boolean\n  /**\n   * A boolean indicating if the form is valid.\n   */\n  isFormValid: boolean\n  /**\n   * The error array for the form itself.\n   */\n  errors: ValidationError[]\n  /**\n   * A boolean indicating if any of the form fields are currently validating.\n   */\n  isFieldsValidating: boolean\n  /**\n   * A boolean indicating if all the form fields are valid.\n   */\n  isFieldsValid: boolean\n  /**\n   * A boolean indicating if any of the form fields have been touched.\n   */\n  isTouched: boolean\n  /**\n   * A boolean indicating if any of the form fields have been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A boolean indicating if any of the form's fields' values have been modified by the user. `True` if the user have modified at least one of the fields. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A boolean indicating if none of the form's fields' values have been modified by the user. `True` if the user have not modified any of the fields. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if the form and all its fields are valid.\n   */\n  isValid: boolean\n  /**\n   * A boolean indicating if the form can be submitted based on its current state.\n   */\n  canSubmit: boolean\n  /**\n   * A record of field metadata for each field in the form.\n   */\n  fieldMeta: Record<DeepKeys<TFormData>, FieldMeta>\n}\n\nexport type FormState<TFormData> = BaseFormState<TFormData> &\n  DerivedFormState<TFormData>\n\nfunction getDefaultFormState<TFormData>(\n  defaultState: Partial<FormState<TFormData>>,\n): BaseFormState<TFormData> {\n  return {\n    values: defaultState.values ?? ({} as never),\n    errorMap: defaultState.errorMap ?? {},\n    fieldMetaBase: defaultState.fieldMetaBase ?? ({} as never),\n    isSubmitted: defaultState.isSubmitted ?? false,\n    isSubmitting: defaultState.isSubmitting ?? false,\n    isValidating: defaultState.isValidating ?? false,\n    submissionAttempts: defaultState.submissionAttempts ?? 0,\n    validationMetaMap: defaultState.validationMetaMap ?? {\n      onChange: undefined,\n      onBlur: undefined,\n      onSubmit: undefined,\n      onMount: undefined,\n      onServer: undefined,\n    },\n  }\n}\n\nconst isFormValidationError = (\n  error: unknown,\n): error is FormValidationError<unknown> => {\n  return typeof error === 'object'\n}\n\n/**\n * A class representing the Form API. It handles the logic and interactions with the form state.\n *\n * Normally, you will not need to create a new `FormApi` instance directly. Instead, you will use a framework\n * hook/function like `useForm` or `createForm` to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling the `new FormApi` constructor.\n */\nexport class FormApi<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  /**\n   * The options for the form.\n   */\n  options: FormOptions<TFormData, TFormValidator> = {}\n  baseStore!: Store<BaseFormState<TFormData>>\n  fieldMetaDerived!: Derived<Record<DeepKeys<TFormData>, FieldMeta>>\n  store!: Derived<FormState<TFormData>>\n  /**\n   * A record of field information for each field in the form.\n   */\n  fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData, TFormValidator>> =\n    {} as any\n\n  get state() {\n    return this.store.state\n  }\n\n  /**\n   * @private\n   */\n  prevTransformArray: unknown[] = []\n\n  /**\n   * Constructs a new `FormApi` instance with the given form options.\n   */\n  constructor(opts?: FormOptions<TFormData, TFormValidator>) {\n    this.baseStore = new Store(\n      getDefaultFormState({\n        ...(opts?.defaultState as any),\n        values: opts?.defaultValues ?? opts?.defaultState?.values,\n        isFormValid: true,\n      }),\n    )\n\n    this.fieldMetaDerived = new Derived({\n      deps: [this.baseStore],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | Record<DeepKeys<TFormData>, FieldMeta>\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n\n        const fieldMeta = {} as FormState<TFormData>['fieldMeta']\n        for (const fieldName of Object.keys(\n          currBaseStore.fieldMetaBase,\n        ) as Array<keyof typeof currBaseStore.fieldMetaBase>) {\n          const currBaseVal = currBaseStore.fieldMetaBase[\n            fieldName as never\n          ] as FieldMetaBase\n\n          const prevBaseVal = prevBaseStore?.fieldMetaBase[\n            fieldName as never\n          ] as FieldMetaBase | undefined\n\n          const prevFieldInfo =\n            prevVal?.[fieldName as never as keyof typeof prevVal]\n\n          let fieldErrors = prevFieldInfo?.errors\n          if (!prevBaseVal || currBaseVal.errorMap !== prevBaseVal.errorMap) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldErrors = Object.values(currBaseVal.errorMap ?? {}).filter(\n              (val: unknown) => val !== undefined,\n            )\n          }\n\n          // As a primitive, we don't need to aggressively persist the same referencial value for performance reasons\n          const isFieldPristine = !currBaseVal.isDirty\n\n          if (\n            prevFieldInfo &&\n            prevFieldInfo.isPristine === isFieldPristine &&\n            prevFieldInfo.errors === fieldErrors &&\n            currBaseVal === prevBaseVal\n          ) {\n            fieldMeta[fieldName] = prevFieldInfo\n            continue\n          }\n\n          fieldMeta[fieldName] = {\n            ...currBaseVal,\n            errors: fieldErrors,\n            isPristine: isFieldPristine,\n          } as FieldMeta\n        }\n\n        return fieldMeta\n      },\n    })\n\n    this.store = new Derived({\n      deps: [this.baseStore, this.fieldMetaDerived],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as FormState<TFormData> | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n\n        // Computed state\n        const fieldMetaValues = Object.values(currBaseStore.fieldMetaBase) as (\n          | FieldMeta\n          | undefined\n        )[]\n\n        const isFieldsValidating = fieldMetaValues.some(\n          (field) => field?.isValidating,\n        )\n\n        const isFieldsValid = !fieldMetaValues.some(\n          (field) =>\n            field?.errorMap &&\n            isNonEmptyArray(Object.values(field.errorMap).filter(Boolean)),\n        )\n\n        const isTouched = fieldMetaValues.some((field) => field?.isTouched)\n        const isBlurred = fieldMetaValues.some((field) => field?.isBlurred)\n\n        const shouldInvalidateOnMount =\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          isTouched && currBaseStore?.errorMap?.onMount\n\n        const isDirty = fieldMetaValues.some((field) => field?.isDirty)\n        const isPristine = !isDirty\n\n        const hasOnMountError = Boolean(\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          currBaseStore.errorMap?.onMount ||\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMetaValues.some((f) => f?.errorMap?.onMount),\n        )\n\n        const isValidating = !!isFieldsValidating\n\n        // As `errors` is not a primitive, we need to aggressively persist the same referencial value for performance reasons\n        let errors = prevVal?.errors ?? []\n        if (\n          !prevBaseStore ||\n          currBaseStore.errorMap !== prevBaseStore.errorMap\n        ) {\n          errors = Object.values(currBaseStore.errorMap).reduce(\n            (prev, curr) => {\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              if (curr === undefined) return prev\n              if (typeof curr === 'string') {\n                prev.push(curr)\n                return prev\n              } else if (curr && isFormValidationError(curr)) {\n                prev.push(curr.form)\n                return prev\n              }\n              return prev\n            },\n            [] as ValidationError[],\n          )\n        }\n\n        const isFormValid = errors.length === 0\n        const isValid = isFieldsValid && isFormValid\n        const canSubmit =\n          (currBaseStore.submissionAttempts === 0 &&\n            !isTouched &&\n            !hasOnMountError) ||\n          (!isValidating && !currBaseStore.isSubmitting && isValid)\n\n        let errorMap = currBaseStore.errorMap\n        if (shouldInvalidateOnMount) {\n          errors = errors.filter(\n            (err) => err !== currBaseStore.errorMap.onMount,\n          )\n          errorMap = Object.assign(errorMap, { onMount: undefined })\n        }\n\n        let state = {\n          ...currBaseStore,\n          errorMap,\n          fieldMeta: this.fieldMetaDerived.state,\n          errors,\n          isFieldsValidating,\n          isFieldsValid,\n          isFormValid,\n          isValid,\n          canSubmit,\n          isTouched,\n          isBlurred,\n          isPristine,\n          isDirty,\n        } as FormState<TFormData>\n\n        // Only run transform if state has shallowly changed - IE how React.useEffect works\n        const transformArray = this.options.transform?.deps ?? []\n        const shouldTransform =\n          transformArray.length !== this.prevTransformArray.length ||\n          transformArray.some((val, i) => val !== this.prevTransformArray[i])\n\n        if (shouldTransform) {\n          const newObj = Object.assign({}, this, { state })\n          // This mutates the state\n          this.options.transform?.fn(newObj)\n          state = newObj.state\n          this.prevTransformArray = transformArray\n        }\n\n        return state\n      },\n    })\n\n    this.update(opts || {})\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends {\n      value: TFormData\n      formApi: FormApi<any, any>\n      validationSource: ValidationSource\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FormValidateOrFn<TFormData, TFormValidator>\n      : FormAsyncValidateOrFn<TFormData, TFormValidator>\n    value: TValue\n    type: TType\n  }): ReturnType<ReturnType<Validator<any>>[TType]> {\n    const adapter = this.options.validatorAdapter\n    if (\n      adapter &&\n      (typeof props.validate !== 'function' || '~standard' in props.validate)\n    ) {\n      return adapter()[props.type](props.value, props.validate) as never\n    }\n\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidator()()[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FormValidateFn<any, any>)(props.value) as never\n  }\n\n  mount = () => {\n    const cleanupFieldMetaDerived = this.fieldMetaDerived.mount()\n    const cleanupStoreDerived = this.store.mount()\n    const cleanup = () => {\n      cleanupFieldMetaDerived()\n      cleanupStoreDerived()\n    }\n    const { onMount } = this.options.validators || {}\n    if (!onMount) return cleanup\n    this.validateSync('mount')\n\n    return cleanup\n  }\n\n  /**\n   * Updates the form options and form state.\n   */\n  update = (options?: FormOptions<TFormData, TFormValidator>) => {\n    if (!options) return\n\n    const oldOptions = this.options\n\n    // Options need to be updated first so that when the store is updated, the state is correct for the derived state\n    this.options = options\n\n    batch(() => {\n      const shouldUpdateValues =\n        options.defaultValues &&\n        options.defaultValues !== oldOptions.defaultValues &&\n        !this.state.isTouched\n\n      const shouldUpdateState =\n        options.defaultState !== oldOptions.defaultState &&\n        !this.state.isTouched\n\n      this.baseStore.setState(() =>\n        getDefaultFormState(\n          Object.assign(\n            {},\n            this.state as any,\n\n            shouldUpdateState ? options.defaultState : {},\n\n            shouldUpdateValues\n              ? {\n                  values: options.defaultValues,\n                }\n              : {},\n          ),\n        ),\n      )\n    })\n  }\n\n  /**\n   * Resets the form state to the default values.\n   * If values are provided, the form will be reset to those values instead and the default values will be updated.\n   *\n   * @param values - Optional values to reset the form to.\n   * @param opts - Optional options to control the reset behavior.\n   */\n  reset = (values?: TFormData, opts?: { keepDefaultValues?: boolean }) => {\n    const { fieldMeta: currentFieldMeta } = this.state\n    const fieldMetaBase = this.resetFieldMeta(currentFieldMeta)\n\n    if (values && !opts?.keepDefaultValues) {\n      this.options = {\n        ...this.options,\n        defaultValues: values,\n      }\n    }\n\n    this.baseStore.setState(() =>\n      getDefaultFormState({\n        ...(this.options.defaultState as any),\n        values:\n          values ??\n          this.options.defaultValues ??\n          this.options.defaultState?.values,\n        fieldMetaBase,\n      }),\n    )\n  }\n\n  /**\n   * Validates form and all fields in using the correct handlers for a given validation cause.\n   */\n  validateAllFields = async (cause: ValidationCause) => {\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      void (\n        Object.values(this.fieldInfo) as FieldInfo<any, TFormValidator>[]\n      ).forEach((field) => {\n        if (!field.instance) return\n        const fieldInstance = field.instance\n        // Validate the field\n        fieldValidationPromises.push(\n          // Remember, `validate` is either a sync operation or a promise\n          Promise.resolve().then(() => fieldInstance.validate(cause)),\n        )\n        // If any fields are not touched\n        if (!field.instance.state.meta.isTouched) {\n          // Mark them as touched\n          field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n        }\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates the children of a specified array in the form starting from a given index until the end using the correct handlers for a given validation type.\n   */\n  validateArrayFieldsStartingFrom = async <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index: number,\n    cause: ValidationCause,\n  ) => {\n    const currentValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(currentValue)\n      ? Math.max(currentValue.length - 1, 0)\n      : null\n\n    // We have to validate all fields that have shifted (at least the current field)\n    const fieldKeysToValidate = [`${field}[${index}]`]\n    for (let i = index + 1; i <= (lastIndex ?? 0); i++) {\n      fieldKeysToValidate.push(`${field}[${i}]`)\n    }\n\n    // We also have to include all fields that are nested in the shifted fields\n    const fieldsToValidate = Object.keys(this.fieldInfo).filter((fieldKey) =>\n      fieldKeysToValidate.some((key) => fieldKey.startsWith(key)),\n    ) as DeepKeys<TFormData>[]\n\n    // Validate the fields\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      fieldsToValidate.forEach((nestedField) => {\n        fieldValidationPromises.push(\n          Promise.resolve().then(() => this.validateField(nestedField, cause)),\n        )\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates a specified field in the form using the correct handlers for a given validation type.\n   */\n  validateField = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    cause: ValidationCause,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const fieldInstance = this.fieldInfo[field]?.instance\n    if (!fieldInstance) return []\n\n    // If the field is not touched (same logic as in validateAllFields)\n    if (!fieldInstance.state.meta.isTouched) {\n      // Mark it as touched\n      fieldInstance.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n\n    return fieldInstance.validate(cause)\n  }\n\n  /**\n   * TODO: This code is copied from FieldApi, we should refactor to share\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n  ): {\n    hasErrored: boolean\n    fieldsErrorMap: FieldsErrorMapFromValidator<TFormData>\n  } => {\n    const validates = getSyncValidatorArray(cause, this.options)\n    let hasErrored = false as boolean\n\n    const fieldsErrorMap: FieldsErrorMapFromValidator<TFormData> = {}\n\n    batch(() => {\n      for (const validateObj of validates) {\n        if (!validateObj.validate) continue\n\n        const rawError = this.runValidator({\n          validate: validateObj.validate,\n          value: {\n            value: this.state.values,\n            formApi: this,\n            validationSource: 'form',\n          },\n          type: 'validate',\n        })\n\n        const { formError, fieldErrors } = normalizeError<TFormData>(rawError)\n\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        if (fieldErrors) {\n          for (const [field, fieldError] of Object.entries(fieldErrors)) {\n            const oldErrorMap =\n              fieldsErrorMap[field as DeepKeys<TFormData>] || {}\n            const newErrorMap = {\n              ...oldErrorMap,\n              [errorMapKey]: fieldError,\n            }\n            fieldsErrorMap[field as DeepKeys<TFormData>] = newErrorMap\n\n            const fieldMeta = this.getFieldMeta(field as DeepKeys<TFormData>)\n            if (fieldMeta && fieldMeta.errorMap[errorMapKey] !== fieldError) {\n              this.setFieldMeta(field as DeepKeys<TFormData>, (prev) => ({\n                ...prev,\n                errorMap: {\n                  ...prev.errorMap,\n                  [errorMapKey]: fieldError,\n                },\n              }))\n            }\n          }\n        }\n\n        if (this.state.errorMap[errorMapKey] !== formError) {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        }\n\n        if (formError || fieldErrors) {\n          hasErrored = true\n        }\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n    if (\n      this.state.errorMap[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.baseStore.setState((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored, fieldsErrorMap }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n  ): Promise<FieldsErrorMapFromValidator<TFormData>> => {\n    const validates = getAsyncValidatorArray(cause, this.options)\n\n    if (!this.state.isFormValidating) {\n      this.baseStore.setState((prev) => ({ ...prev, isFormValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const promises: Promise<ValidationPromiseResult<TFormData>>[] = []\n\n    let fieldErrors:\n      | Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      | undefined\n\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      const key = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = this.state.validationMetaMap[key]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.state.validationMetaMap[key] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationPromiseResult<TFormData>>(async (resolve) => {\n          let rawError!:\n            | ValidationError\n            | FormValidationError<unknown>\n            | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate!,\n                      value: {\n                        value: this.state.values,\n                        formApi: this,\n                        validationSource: 'form',\n                        signal: controller.signal,\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          const { formError, fieldErrors: fieldErrorsFromNormalizeError } =\n            normalizeError<TFormData>(rawError)\n\n          if (fieldErrorsFromNormalizeError) {\n            fieldErrors = fieldErrors\n              ? { ...fieldErrors, ...fieldErrorsFromNormalizeError }\n              : fieldErrorsFromNormalizeError\n          }\n          const errorMapKey = getErrorMapKey(validateObj.cause)\n\n          if (fieldErrors) {\n            for (const [field, fieldError] of Object.entries(fieldErrors)) {\n              const fieldMeta = this.getFieldMeta(field as DeepKeys<TFormData>)\n              if (fieldMeta && fieldMeta.errorMap[errorMapKey] !== fieldError) {\n                this.setFieldMeta(field as DeepKeys<TFormData>, (prev) => ({\n                  ...prev,\n                  errorMap: {\n                    ...prev.errorMap,\n                    [errorMapKey]: fieldError,\n                  },\n                }))\n              }\n            }\n          }\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n\n          resolve(fieldErrors ? { fieldErrors, errorMapKey } : undefined)\n        }),\n      )\n    }\n\n    let results: ValidationPromiseResult<TFormData>[] = []\n\n    const fieldsErrorMap: FieldsErrorMapFromValidator<TFormData> = {}\n    if (promises.length) {\n      results = await Promise.all(promises)\n      for (const fieldValidationResult of results) {\n        if (fieldValidationResult?.fieldErrors) {\n          const { errorMapKey } = fieldValidationResult\n\n          for (const [field, fieldError] of Object.entries(\n            fieldValidationResult.fieldErrors,\n          )) {\n            const oldErrorMap =\n              fieldsErrorMap[field as DeepKeys<TFormData>] || {}\n            const newErrorMap = {\n              ...oldErrorMap,\n              [errorMapKey]: fieldError,\n            }\n            fieldsErrorMap[field as DeepKeys<TFormData>] = newErrorMap\n          }\n        }\n      }\n    }\n\n    this.baseStore.setState((prev) => ({\n      ...prev,\n      isFormValidating: false,\n    }))\n\n    return fieldsErrorMap\n  }\n\n  /**\n   * @private\n   */\n  validate = (\n    cause: ValidationCause,\n  ):\n    | FieldsErrorMapFromValidator<TFormData>\n    | Promise<FieldsErrorMapFromValidator<TFormData>> => {\n    // Attempt to sync validate first\n    const { hasErrored, fieldsErrorMap } = this.validateSync(cause)\n\n    if (hasErrored && !this.options.asyncAlways) {\n      return fieldsErrorMap\n    }\n\n    // No error? Attempt async validation\n    return this.validateAsync(cause)\n  }\n\n  /**\n   * Handles the form submission, performs validation, and calls the appropriate onSubmit or onInvalidSubmit callbacks.\n   */\n  handleSubmit = async () => {\n    this.baseStore.setState((old) => ({\n      ...old,\n      // Submission attempts mark the form as not submitted\n      isSubmitted: false,\n      // Count submission attempts\n      submissionAttempts: old.submissionAttempts + 1,\n    }))\n\n    // Don't let invalid forms submit\n    if (!this.state.canSubmit) return\n\n    this.baseStore.setState((d) => ({ ...d, isSubmitting: true }))\n\n    const done = () => {\n      this.baseStore.setState((prev) => ({ ...prev, isSubmitting: false }))\n    }\n\n    // Validate form and all fields\n    await this.validateAllFields('submit')\n\n    // Fields are invalid, do not submit\n    if (!this.state.isValid) {\n      done()\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n      })\n      return\n    }\n\n    batch(() => {\n      void (\n        Object.values(this.fieldInfo) as FieldInfo<TFormData, TFormValidator>[]\n      ).forEach((field) => {\n        field.instance?.options.listeners?.onSubmit?.({\n          value: field.instance.state.value,\n          fieldApi: field.instance,\n        })\n      })\n    })\n\n    try {\n      // Run the submit code\n      await this.options.onSubmit?.({ value: this.state.values, formApi: this })\n\n      batch(() => {\n        this.baseStore.setState((prev) => ({ ...prev, isSubmitted: true }))\n        done()\n      })\n    } catch (err) {\n      done()\n      throw err\n    }\n  }\n\n  /**\n   * Gets the value of the specified field.\n   */\n  getFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): DeepValue<TFormData, TField> => getBy(this.state.values, field)\n\n  /**\n   * Gets the metadata of the specified field.\n   */\n  getFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldMeta | undefined => {\n    return this.state.fieldMeta[field]\n  }\n\n  /**\n   * Gets the field info of the specified field.\n   */\n  getFieldInfo = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldInfo<TFormData, TFormValidator> => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return (this.fieldInfo[field] ||= {\n      instance: null,\n      validationMetaMap: {\n        onChange: undefined,\n        onBlur: undefined,\n        onSubmit: undefined,\n        onMount: undefined,\n        onServer: undefined,\n      },\n    })\n  }\n\n  /**\n   * Updates the metadata of the specified field.\n   */\n  setFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<FieldMeta>,\n  ) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: functionalUpdate(\n            updater,\n            prev.fieldMetaBase[field] as never,\n          ),\n        },\n      }\n    })\n  }\n\n  resetFieldMeta = <TField extends DeepKeys<TFormData>>(\n    fieldMeta: Record<TField, FieldMeta>,\n  ): Record<TField, FieldMeta> => {\n    return Object.keys(fieldMeta).reduce(\n      (acc: Record<TField, FieldMeta>, key) => {\n        const fieldKey = key as TField\n        acc[fieldKey] = {\n          isValidating: false,\n          isTouched: false,\n          isBlurred: false,\n          isDirty: false,\n          isPristine: true,\n          errors: [],\n          errorMap: {},\n        }\n        return acc\n      },\n      {} as Record<TField, FieldMeta>,\n    )\n  }\n\n  /**\n   * Sets the value of the specified field and optionally updates the touched state.\n   */\n  setFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<DeepValue<TFormData, TField>>,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const dontUpdateMeta = opts?.dontUpdateMeta ?? false\n\n    batch(() => {\n      if (!dontUpdateMeta) {\n        this.setFieldMeta(field, (prev) => ({\n          ...prev,\n          isTouched: true,\n          isDirty: true,\n          errorMap: {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            ...prev?.errorMap,\n            onMount: undefined,\n          },\n        }))\n      }\n\n      this.baseStore.setState((prev) => {\n        return {\n          ...prev,\n          values: setBy(prev.values, field, updater),\n        }\n      })\n    })\n  }\n\n  deleteField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    this.baseStore.setState((prev) => {\n      const newState = { ...prev }\n      newState.values = deleteBy(newState.values, field)\n      delete newState.fieldMetaBase[field]\n\n      return newState\n    })\n    delete this.fieldInfo[field]\n  }\n\n  /**\n   * Pushes a value into an array field.\n   */\n  pushFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => [...(Array.isArray(prev) ? prev : []), value] as any,\n      opts,\n    )\n    this.validateField(field, 'change')\n  }\n\n  /**\n   * Inserts a value into an array field at the specified index, shifting the subsequent values to the right.\n   */\n  insertFieldValue = async <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return [\n          ...(prev as DeepValue<TFormData, TField>[]).slice(0, index),\n          value,\n          ...(prev as DeepValue<TFormData, TField>[]).slice(index),\n        ] as any\n      },\n      opts,\n    )\n\n    // Validate the whole array + all fields that have shifted\n    await this.validateField(field, 'change')\n  }\n\n  /**\n   * Replaces a value into an array field at the specified index.\n   */\n  replaceFieldValue = async <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).map((d, i) =>\n          i === index ? value : d,\n        ) as any\n      },\n      opts,\n    )\n\n    // Validate the whole array + all fields that have shifted\n    await this.validateField(field, 'change')\n    await this.validateArrayFieldsStartingFrom(field, index, 'change')\n  }\n\n  /**\n   * Removes a value from an array field at the specified index.\n   */\n  removeFieldValue = async <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index: number,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max(fieldValue.length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).filter(\n          (_d, i) => i !== index,\n        ) as any\n      },\n      opts,\n    )\n\n    if (lastIndex !== null) {\n      const start = `${field}[${lastIndex}]`\n      const fieldsToDelete = Object.keys(this.fieldInfo).filter((f) =>\n        f.startsWith(start),\n      )\n\n      // Cleanup the last fields\n      fieldsToDelete.forEach((f) => this.deleteField(f as TField))\n    }\n\n    // Validate the whole array + all fields that have shifted\n    await this.validateField(field, 'change')\n    await this.validateArrayFieldsStartingFrom(field, index, 'change')\n  }\n\n  /**\n   * Swaps the values at the specified indices within an array field.\n   */\n  swapFieldValues = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const prev1 = prev[index1]!\n        const prev2 = prev[index2]!\n        return setBy(setBy(prev, `${index1}`, prev2), `${index2}`, prev1)\n      },\n      opts,\n    )\n\n    // Validate the whole array\n    this.validateField(field, 'change')\n    // Validate the swapped fields\n    this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n    this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index within an array field.\n   */\n  moveFieldValues = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    opts?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        prev.splice(index2, 0, prev.splice(index1, 1)[0])\n        return prev\n      },\n      opts,\n    )\n\n    // Validate the whole array\n    this.validateField(field, 'change')\n    // Validate the moved fields\n    this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n    this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n  }\n  /**\n   * Updates the form's errorMap\n   */\n  setErrorMap(errorMap: ValidationErrorMap) {\n    this.baseStore.setState((prev) => ({\n      ...prev,\n      errorMap: {\n        ...prev.errorMap,\n        ...errorMap,\n      },\n    }))\n  }\n}\n\nfunction normalizeError<TFormData>(rawError?: FormValidationError<unknown>): {\n  formError: ValidationError\n  fieldErrors?: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n} {\n  if (rawError) {\n    if (typeof rawError === 'object') {\n      const formError = normalizeError(rawError.form).formError\n      const fieldErrors = rawError.fields\n      return { formError, fieldErrors } as never\n    }\n\n    if (typeof rawError !== 'string') {\n      return { formError: 'Invalid Form Values' }\n    }\n\n    return { formError: rawError }\n  }\n\n  return { formError: undefined }\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n", "import { Derived, batch } from '@tanstack/store'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidator,\n} from './standardSchemaValidator'\nimport { getAsyncValidatorArray, getBy, getSyncValidatorArray } from './utils'\nimport type { FieldInfo, FieldsErrorMapFromValidator, FormApi } from './FormApi'\nimport type { StandardSchemaV1 } from './standardSchemaValidator'\nimport type {\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationSource,\n  Validator,\n} from './types'\nimport type { DeepKeys, DeepValue, NoInfer } from './util-types'\nimport type { AsyncValidator, SyncValidator, Updater } from './utils'\n\n/**\n * @private\n */\nexport type FieldValidateFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<TParentData, TName, TFieldValidator, TFormValidator, TData>\n}) => ValidationError\n\n/**\n * @private\n */\nexport type FieldValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | (TFieldValidator extends Validator<TData, infer TFN> ? TFN : never)\n  | (TFormValidator extends Validator<TParentData, infer FFN> ? FFN : never)\n  | FieldValidateFn<TParentData, TName, TFieldValidator, TFormValidator, TData>\n  | StandardSchemaV1<TData, unknown>\n\n/**\n * @private\n */\nexport type FieldValidateAsyncFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (options: {\n  value: TData\n  fieldApi: FieldApi<TParentData, TName, TFieldValidator, TFormValidator, TData>\n  signal: AbortSignal\n}) => ValidationError | Promise<ValidationError>\n\n/**\n * @private\n */\nexport type FieldAsyncValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | (TFieldValidator extends Validator<TData, infer TFN> ? TFN : never)\n  | (TFormValidator extends Validator<TParentData, infer FFN> ? FFN : never)\n  | FieldValidateAsyncFn<\n      TParentData,\n      TName,\n      TFieldValidator,\n      TFormValidator,\n      TData\n    >\n  | StandardSchemaV1<TData, unknown>\n\n/**\n * @private\n */\nexport type FieldListenerFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<TParentData, TName, TFieldValidator, TFormValidator, TData>\n}) => void\n\nexport interface FieldValidators<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  /**\n   * An optional function that takes a param of `formApi` which is a generic type of `TData` and `TParentData`\n   */\n  onMount?: FieldValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional property that takes a `ValidateFn` which is a generic of `TData` and `TParentData`.\n   * If `validatorAdapter` is passed, this may also accept a property from the respective adapter\n   *\n   * @example z.string().min(1) // if `zodAdapter` is passed\n   */\n  onChange?: FieldValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional property similar to `onChange` but async validation. If `validatorAdapter`\n   * is passed, this may also accept a property from the respective adapter\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' }) // if `zodAdapter` is passed\n   */\n  onChangeAsync?: FieldAsyncValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional number to represent how long the `onChangeAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onChange` and `onChangeAsync` events when its value changes\n   */\n  onChangeListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the blur event of input.\n   * If `validatorAdapter` is passed, this may also accept a property from the respective adapter\n   *\n   * @example z.string().min(1) // if `zodAdapter` is passed\n   */\n  onBlur?: FieldValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional property similar to `onBlur` but async validation. If `validatorAdapter`\n   * is passed, this may also accept a property from the respective adapter\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' }) // if `zodAdapter` is passed\n   */\n  onBlurAsync?: FieldAsyncValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n\n  /**\n   * An optional number to represent how long the `onBlurAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onBlurAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onBlur` and `onBlurAsync` events when its value changes\n   */\n  onBlurListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the submit event of form.\n   * If `validatorAdapter` is passed, this may also accept a property from the respective adapter\n   *\n   * @example z.string().min(1) // if `zodAdapter` is passed\n   */\n  onSubmit?: FieldValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional property similar to `onSubmit` but async validation. If `validatorAdapter`\n   * is passed, this may also accept a property from the respective adapter\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' }) // if `zodAdapter` is passed\n   */\n  onSubmitAsync?: FieldAsyncValidateOrFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n}\n\nexport interface FieldListeners<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  onChange?: FieldListenerFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  onBlur?: FieldListenerFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  onMount?: FieldListenerFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  onSubmit?: FieldListenerFn<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n}\n\n/**\n * An object type representing the options for a field in a form.\n */\nexport interface FieldOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  /**\n   * The field name. The type will be `DeepKeys<TParentData>` to ensure your name is a deep key of the parent dataset.\n   */\n  name: TName\n  /**\n   * An optional default value for the field.\n   */\n  defaultValue?: NoInfer<TData>\n  /**\n   * The default time to debounce async validation if there is not a more specific debounce time passed.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If `true`, always run async validation, even if there are errors emitted during synchronous validation.\n   */\n  asyncAlways?: boolean\n  /**\n   * A validator provided by an extension, like `yupValidator` from `@tanstack/yup-form-adapter`\n   */\n  validatorAdapter?: TFieldValidator\n  /**\n   * A list of validators to pass to the field\n   */\n  validators?: FieldValidators<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n  /**\n   * An optional object with default metadata for the field.\n   */\n  defaultMeta?: Partial<FieldMeta>\n  /**\n   * A list of listeners which attach to the corresponding events\n   */\n  listeners?: FieldListeners<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >\n}\n\n/**\n * An object type representing the required options for the FieldApi class.\n */\nexport interface FieldApiOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> extends FieldOptions<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  > {\n  form: FormApi<TParentData, TFormValidator>\n}\n\nexport type FieldMetaBase = {\n  /**\n   * A flag indicating whether the field has been touched.\n   */\n  isTouched: boolean\n  /**\n   * A flag indicating whether the field has been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A flag that is `true` if the field's value has been modified by the user. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A map of errors related to the field value.\n   */\n  errorMap: ValidationErrorMap\n  /**\n   * A flag indicating whether the field is currently being validated.\n   */\n  isValidating: boolean\n}\n\nexport type FieldMetaDerived = {\n  /**\n   * An array of errors related to the field value.\n   */\n  errors: ValidationError[]\n  /**\n   * A flag that is `true` if the field's value has not been modified by the user. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n}\n\n/**\n * An object type representing the metadata of a field in a form.\n */\nexport type FieldMeta = FieldMetaBase & FieldMetaDerived\n\n/**\n * An object type representing the state of a field.\n */\nexport type FieldState<TData> = {\n  /**\n   * The current value of the field.\n   */\n  value: TData\n  /**\n   * The current metadata of the field.\n   */\n  meta: FieldMeta\n}\n\n/**\n * A class representing the API for managing a form field.\n *\n * Normally, you will not need to create a new `FieldApi` instance directly.\n * Instead, you will use a framework hook/function like `useField` or `createField`\n * to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling\n * the `new FieldApi` constructor.\n */\nexport class FieldApi<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  /**\n   * A reference to the form API instance.\n   */\n  form: FieldApiOptions<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >['form']\n  /**\n   * The field name.\n   */\n  name!: DeepKeys<TParentData>\n  /**\n   * The field options.\n   */\n  options: FieldApiOptions<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  > = {} as any\n  /**\n   * The field state store.\n   */\n  store!: Derived<FieldState<TData>>\n  /**\n   * The current field state.\n   */\n  get state() {\n    return this.store.state\n  }\n  timeoutIds: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n\n  /**\n   * Initializes a new `FieldApi` instance.\n   */\n  constructor(\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TFieldValidator,\n      TFormValidator,\n      TData\n    >,\n  ) {\n    this.form = opts.form as never\n    this.name = opts.name as never\n    this.timeoutIds = {} as Record<ValidationCause, never>\n    if (opts.defaultValue !== undefined) {\n      this.form.setFieldValue(this.name, opts.defaultValue as never, {\n        dontUpdateMeta: true,\n      })\n    }\n\n    this.store = new Derived({\n      deps: [this.form.store],\n      fn: () => {\n        const value = this.form.getFieldValue(this.name)\n        const meta = this.form.getFieldMeta(this.name) ?? {\n          isValidating: false,\n          isTouched: false,\n          isBlurred: false,\n          isDirty: false,\n          isPristine: true,\n          errors: [],\n          errorMap: {},\n          ...opts.defaultMeta,\n        }\n\n        return {\n          value,\n          meta,\n        } as FieldState<TData>\n      },\n    })\n\n    this.options = opts as never\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends {\n      value: TData\n      fieldApi: FieldApi<any, any, any, any>\n      validationSource: ValidationSource\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FieldValidateOrFn<any, any, any, any>\n      : FieldAsyncValidateOrFn<any, any, any, any>\n    value: TValue\n    type: TType\n    // When `api` is 'field', the return type cannot be `FormValidationError`\n  }): TType extends 'validate' ? ValidationError : Promise<ValidationError> {\n    const adapters = [\n      this.form.options.validatorAdapter,\n      this.options.validatorAdapter,\n    ] as const\n    for (const adapter of adapters) {\n      if (\n        adapter &&\n        (typeof props.validate !== 'function' || '~standard' in props.validate)\n      ) {\n        return adapter()[props.type](\n          props.value as never,\n          props.validate,\n        ) as never\n      }\n    }\n\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidator()()[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FieldValidateFn<any, any>)(props.value) as never\n  }\n\n  /**\n   * Mounts the field instance to the form.\n   */\n  mount = () => {\n    const cleanup = this.store.mount()\n\n    const info = this.getInfo()\n    info.instance = this as never\n\n    this.update(this.options as never)\n    const { onMount } = this.options.validators || {}\n\n    if (onMount) {\n      const error = this.runValidator({\n        validate: onMount,\n        value: {\n          value: this.state.value,\n          fieldApi: this,\n          validationSource: 'field',\n        },\n        type: 'validate',\n      })\n      if (error) {\n        this.setMeta((prev) => ({\n          ...prev,\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          errorMap: { ...prev?.errorMap, onMount: error },\n        }))\n      }\n    }\n\n    this.options.listeners?.onMount?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n\n    return cleanup\n  }\n\n  /**\n   * Updates the field instance with new options.\n   */\n  update = (\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TFieldValidator,\n      TFormValidator,\n      TData\n    >,\n  ) => {\n    // Default Value\n\n    if (this.state.value === undefined) {\n      const formDefault = getBy(opts.form.options.defaultValues, opts.name)\n\n      if (opts.defaultValue !== undefined) {\n        this.setValue(opts.defaultValue as never, {\n          dontUpdateMeta: true,\n        })\n      } else if (formDefault !== undefined) {\n        this.setValue(formDefault as never, {\n          dontUpdateMeta: true,\n        })\n      }\n    }\n\n    // Default Meta\n    if (this.form.getFieldMeta(this.name) === undefined) {\n      this.setMeta(this.state.meta)\n    }\n\n    this.options = opts as never\n    this.name = opts.name\n  }\n\n  /**\n   * Gets the current field value.\n   * @deprecated Use `field.state.value` instead.\n   */\n  getValue = (): TData => {\n    return this.form.getFieldValue(this.name) as TData\n  }\n\n  /**\n   * Sets the field value and run the `change` validator.\n   */\n  setValue = (updater: Updater<TData>, options?: UpdateMetaOptions) => {\n    this.form.setFieldValue(this.name, updater as never, options)\n\n    this.options.listeners?.onChange?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n\n    this.validate('change')\n  }\n\n  getMeta = () => this.store.state.meta\n\n  /**\n   * Sets the field metadata.\n   */\n  setMeta = (updater: Updater<FieldMeta>) =>\n    this.form.setFieldMeta(this.name, updater)\n\n  /**\n   * Gets the field information object.\n   */\n  getInfo = () => this.form.getFieldInfo(this.name)\n\n  /**\n   * Pushes a new value to the field.\n   */\n  pushValue = (\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => this.form.pushFieldValue(this.name, value as any, opts)\n\n  /**\n   * Inserts a value at the specified index, shifting the subsequent values to the right.\n   */\n  insertValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => this.form.insertFieldValue(this.name, index, value as any, opts)\n\n  /**\n   * Replaces a value at the specified index.\n   */\n  replaceValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    opts?: UpdateMetaOptions,\n  ) => this.form.replaceFieldValue(this.name, index, value as any, opts)\n\n  /**\n   * Removes a value at the specified index.\n   */\n  removeValue = (index: number, opts?: UpdateMetaOptions) =>\n    this.form.removeFieldValue(this.name, index, opts)\n\n  /**\n   * Swaps the values at the specified indices.\n   */\n  swapValues = (aIndex: number, bIndex: number, opts?: UpdateMetaOptions) =>\n    this.form.swapFieldValues(this.name, aIndex, bIndex, opts)\n\n  /**\n   * Moves the value at the first specified index to the second specified index.\n   */\n  moveValue = (aIndex: number, bIndex: number, opts?: UpdateMetaOptions) =>\n    this.form.moveFieldValues(this.name, aIndex, bIndex, opts)\n\n  /**\n   * @private\n   */\n  getLinkedFields = (cause: ValidationCause) => {\n    const fields = Object.values(this.form.fieldInfo) as FieldInfo<\n      any,\n      TFormValidator\n    >[]\n\n    const linkedFields: FieldApi<any, any, any, any>[] = []\n    for (const field of fields) {\n      if (!field.instance) continue\n      const { onChangeListenTo, onBlurListenTo } =\n        field.instance.options.validators || {}\n      if (\n        cause === 'change' &&\n        onChangeListenTo?.includes(this.name as string)\n      ) {\n        linkedFields.push(field.instance)\n      }\n      if (cause === 'blur' && onBlurListenTo?.includes(this.name as string)) {\n        linkedFields.push(field.instance)\n      }\n    }\n\n    return linkedFields\n  }\n\n  /**\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n    errorFromForm: ValidationErrorMap,\n  ) => {\n    const validates = getSyncValidatorArray(cause, this.options)\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getSyncValidatorArray(cause, field.options)\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<SyncValidator<any> & { field: FieldApi<any, any, any, any> }>,\n    )\n\n    // Needs type cast as eslint errantly believes this is always falsy\n    let hasErrored = false as boolean\n\n    batch(() => {\n      const validateFieldFn = (\n        field: FieldApi<any, any, any, any>,\n        validateObj: SyncValidator<any>,\n      ) => {\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        const error =\n          /*\n            If `validateObj.validate` is `undefined`, then the field doesn't have\n            a validator for this event, but there still could be an error that\n            needs to be cleaned up related to the current event left by the\n            form's validator.\n          */\n          validateObj.validate\n            ? normalizeError(\n                field.runValidator({\n                  validate: validateObj.validate,\n                  value: {\n                    value: field.store.state.value,\n                    validationSource: 'field',\n                    fieldApi: field,\n                  },\n                  type: 'validate',\n                }),\n              )\n            : errorFromForm[errorMapKey]\n\n        if (field.state.meta.errorMap[errorMapKey] !== error) {\n          field.setMeta((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [getErrorMapKey(validateObj.cause)]:\n                // Prefer the error message from the field validators if they exist\n                error ? error : errorFromForm[errorMapKey],\n            },\n          }))\n        }\n        if (error || errorFromForm[errorMapKey]) {\n          hasErrored = true\n        }\n      }\n\n      for (const validateObj of validates) {\n        validateFieldFn(this, validateObj)\n      }\n      for (const fieldValitateObj of linkedFieldValidates) {\n        if (!fieldValitateObj.validate) continue\n        validateFieldFn(fieldValitateObj.field, fieldValitateObj)\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n\n    if (\n      this.state.meta.errorMap[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.setMeta((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n    formValidationResultPromise: Promise<\n      FieldsErrorMapFromValidator<TParentData>\n    >,\n  ) => {\n    const validates = getAsyncValidatorArray(cause, this.options)\n\n    // Get the field-specific error messages that are coming from the form's validator\n    const asyncFormValidationResults = await formValidationResultPromise\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getAsyncValidatorArray(cause, field.options)\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        AsyncValidator<any> & { field: FieldApi<any, any, any, any> }\n      >,\n    )\n\n    if (!this.state.meta.isValidating) {\n      this.setMeta((prev) => ({ ...prev, isValidating: true }))\n    }\n\n    for (const linkedField of linkedFields) {\n      linkedField.setMeta((prev) => ({ ...prev, isValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const validatesPromises: Promise<ValidationError | undefined>[] = []\n    const linkedPromises: Promise<ValidationError | undefined>[] = []\n\n    const validateFieldAsyncFn = (\n      field: FieldApi<any, any, any, any>,\n      validateObj: AsyncValidator<any>,\n      promises: Promise<ValidationError | undefined>[],\n    ) => {\n      const errorMapKey = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = field.getInfo().validationMetaMap[errorMapKey]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.getInfo().validationMetaMap[errorMapKey] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              if (this.timeoutIds[validateObj.cause]) {\n                clearTimeout(this.timeoutIds[validateObj.cause]!)\n              }\n\n              this.timeoutIds[validateObj.cause] = setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate,\n                      value: {\n                        value: field.store.state.value,\n                        fieldApi: field,\n                        signal: controller.signal,\n                        validationSource: 'field',\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          if (controller.signal.aborted) return resolve(undefined)\n          const error = normalizeError(rawError)\n          const fieldErrorFromForm =\n            asyncFormValidationResults[this.name]?.[errorMapKey]\n          const fieldError = error || fieldErrorFromForm\n          field.setMeta((prev) => {\n            return {\n              ...prev,\n              errorMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorMap,\n                [errorMapKey]: fieldError,\n              },\n            }\n          })\n\n          resolve(fieldError)\n        }),\n      )\n    }\n\n    // TODO: Dedupe this logic to reduce bundle size\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      validateFieldAsyncFn(this, validateObj, validatesPromises)\n    }\n    for (const fieldValitateObj of linkedFieldValidates) {\n      if (!fieldValitateObj.validate) continue\n      validateFieldAsyncFn(\n        fieldValitateObj.field,\n        fieldValitateObj,\n        linkedPromises,\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (validatesPromises.length || linkedPromises.length) {\n      results = await Promise.all(validatesPromises)\n      await Promise.all(linkedPromises)\n    }\n\n    this.setMeta((prev) => ({ ...prev, isValidating: false }))\n\n    for (const linkedField of linkedFields) {\n      linkedField.setMeta((prev) => ({ ...prev, isValidating: false }))\n    }\n\n    return results.filter(Boolean)\n  }\n\n  /**\n   * Validates the field value.\n   */\n  validate = (\n    cause: ValidationCause,\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // If the field is pristine, do not validate\n    if (!this.state.meta.isTouched) return []\n\n    // Attempt to sync validate first\n    const { fieldsErrorMap } = this.form.validateSync(cause)\n    const { hasErrored } = this.validateSync(\n      cause,\n      fieldsErrorMap[this.name] ?? {},\n    )\n\n    if (hasErrored && !this.options.asyncAlways) {\n      this.getInfo().validationMetaMap[\n        getErrorMapKey(cause)\n      ]?.lastAbortController.abort()\n      return this.state.meta.errors\n    }\n\n    // No error? Attempt async validation\n    const formValidationResultPromise = this.form.validateAsync(cause)\n    return this.validateAsync(cause, formValidationResultPromise)\n  }\n\n  /**\n   * Handles the change event.\n   */\n  handleChange = (updater: Updater<TData>) => {\n    this.setValue(updater)\n  }\n\n  /**\n   * Handles the blur event.\n   */\n  handleBlur = () => {\n    const prevTouched = this.state.meta.isTouched\n    if (!prevTouched) {\n      this.setMeta((prev) => ({ ...prev, isTouched: true }))\n      this.validate('change')\n    }\n    if (!this.state.meta.isBlurred) {\n      this.setMeta((prev) => ({ ...prev, isBlurred: true }))\n    }\n    this.validate('blur')\n\n    this.options.listeners?.onBlur?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n  }\n\n  /**\n   * Updates the field's errorMap\n   */\n  setErrorMap(errorMap: ValidationErrorMap) {\n    this.setMeta((prev) => ({\n      ...prev,\n      errorMap: {\n        ...prev.errorMap,\n        ...errorMap,\n      },\n    }))\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    if (typeof rawError !== 'string') {\n      return 'Invalid Form Values'\n    }\n\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n", "import type { FormApi } from './FormApi'\nimport type { Validator } from './types'\nimport type { NoInfer } from './util-types'\n\n/**\n * @private\n */\nexport function mutateMergeDeep(target: object, source: object): object {\n  const targetKeys = Object.keys(target)\n  const sourceKeys = Object.keys(source)\n  const keySet = new Set([...targetKeys, ...sourceKeys])\n  for (const key of keySet) {\n    const targetKey = key as never as keyof typeof target\n    const sourceKey = key as never as keyof typeof source\n\n    if (Array.isArray(target[targetKey]) && Array.isArray(source[sourceKey])) {\n      // always use the source array to prevent array fields from multiplying\n      target[targetKey] = source[sourceKey] as [] as never\n    } else if (\n      typeof target[targetKey] === 'object' &&\n      typeof source[sourceKey] === 'object'\n    ) {\n      mutateMergeDeep(target[targetKey] as {}, source[sourceKey] as {})\n    } else {\n      // Prevent assigning undefined to target, only if undefined is not explicitly set on source\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!(sourceKey in source) && source[sourceKey] === undefined) {\n        continue\n      }\n      target[targetKey] = source[sourceKey] as never\n    }\n  }\n  return target\n}\n\nexport function mergeForm<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n>(\n  baseForm: FormApi<NoInfer<TFormData>, NoInfer<TFormValidator>>,\n  state: Partial<FormApi<TFormData, TFormValidator>['state']>,\n) {\n  mutateMergeDeep(baseForm.state, state)\n  return baseForm\n}\n", "import type { Validator } from './types'\nimport type { FormOptions } from './FormApi'\n\nexport function formOptions<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n>(defaultOpts?: FormOptions<TFormData, TFormValidator>) {\n  return defaultOpts\n}\n", "import { useEffect, useLayoutEffect } from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect\n", "import React, { useMemo, useState } from 'react'\nimport { useStore } from '@tanstack/react-store'\nimport { FieldApi, functionalUpdate } from '@tanstack/form-core'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\nimport type { FunctionComponent, ReactNode } from 'react'\nimport type { UseFieldOptions } from './types'\nimport type { DeepKeys, DeepValue, Validator } from '@tanstack/form-core'\n\ninterface ReactFieldApi<\n  TParentData,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n> {\n  /**\n   * A pre-bound and type-safe sub-field component using this field as a root.\n   */\n  Field: FieldComponent<TParentData, TFormValidator>\n}\n\n/**\n * A type representing a hook for using a field in a form with the given form data type.\n *\n * A function that takes an optional object with a `name` property and field options, and returns a `FieldApi` instance for the specified field.\n */\nexport type UseField<\n  TParentData,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n> = <\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n>(\n  opts: Omit<\n    UseFieldOptions<TParentData, TName, TFieldValidator, TFormValidator, TData>,\n    'form'\n  >,\n) => FieldApi<TParentData, TName, TFieldValidator, TFormValidator, TData>\n\n/**\n * A hook for managing a field in a form.\n * @param opts An object with field options.\n *\n * @returns The `FieldApi` instance for the specified field.\n */\nexport function useField<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n>(\n  opts: UseFieldOptions<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >,\n) {\n  const [fieldApi] = useState(() => {\n    const api = new FieldApi({\n      ...opts,\n      form: opts.form,\n      name: opts.name,\n    })\n\n    const extendedApi: typeof api & ReactFieldApi<TParentData, TFormValidator> =\n      api as never\n\n    extendedApi.Field = Field as never\n\n    return extendedApi\n  })\n\n  useIsomorphicLayoutEffect(fieldApi.mount, [fieldApi])\n\n  /**\n   * fieldApi.update should not have any side effects. Think of it like a `useRef`\n   * that we need to keep updated every render with the most up-to-date information.\n   */\n  useIsomorphicLayoutEffect(() => {\n    fieldApi.update(opts)\n  })\n\n  useStore(\n    fieldApi.store,\n    opts.mode === 'array'\n      ? (state) => {\n          return [state.meta, Object.keys(state.value ?? []).length]\n        }\n      : undefined,\n  )\n\n  return fieldApi\n}\n\n/**\n * @param children A render function that takes a field API instance and returns a React element.\n */\ntype FieldComponentProps<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = {\n  children: (\n    fieldApi: FieldApi<\n      TParentData,\n      TName,\n      TFieldValidator,\n      TFormValidator,\n      TData\n    >,\n  ) => ReactNode\n} & UseFieldOptions<TParentData, TName, TFieldValidator, TFormValidator, TData>\n\n/**\n * A type alias representing a field component for a specific form data type.\n */\nexport type FieldComponent<\n  TParentData,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n> = <\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n>({\n  children,\n  ...fieldOptions\n}: Omit<\n  FieldComponentProps<\n    TParentData,\n    TName,\n    TFieldValidator,\n    TFormValidator,\n    TData\n  >,\n  'form'\n>) => ReactNode\n\n/**\n * A function component that takes field options and a render function as children and returns a React component.\n *\n * The `Field` component uses the `useField` hook internally to manage the field instance.\n */\nexport const Field = (<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TFieldValidator extends\n    | Validator<DeepValue<TParentData, TName>, unknown>\n    | undefined = undefined,\n  TFormValidator extends\n    | Validator<TParentData, unknown>\n    | undefined = undefined,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n>({\n  children,\n  ...fieldOptions\n}: FieldComponentProps<\n  TParentData,\n  TName,\n  TFieldValidator,\n  TFormValidator,\n  TData\n>): ReactNode => {\n  const fieldApi = useField(fieldOptions as any)\n\n  const jsxToDisplay = useMemo(\n    () => functionalUpdate(children, fieldApi as any),\n    /**\n     * The reason this exists is to fix an issue with the React Compiler.\n     * Namely, functionalUpdate is memoized where it checks for `fieldApi`, which is a static type.\n     * This means that when `state.value` changes, it does not trigger a re-render. The useMemo explicitly fixes this problem\n     */\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [children, fieldApi, fieldApi.state.value, fieldApi.state.meta],\n  )\n  return (<>{jsxToDisplay}</>) as never\n}) satisfies FunctionComponent<FieldComponentProps<any, any, any, any, any>>\n", "import type { FormApi, FormTransform, Validator } from '@tanstack/form-core'\n\nexport function useTransform<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n>(\n  fn: (formBase: FormApi<any, any>) => FormApi<TFormData, TFormValidator>,\n  deps: unknown[],\n): FormTransform<TFormData, TFormValidator> {\n  return {\n    fn,\n    deps,\n  }\n}\n"],
  "mappings": "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",
  "names": ["opts", "_a", "_c", "_b", "opts", "getErrorMapKey", "normalizeError"]
}
